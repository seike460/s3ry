package s3

import (
	"context"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/aws/aws-sdk-go/service/s3/s3manager"
	"github.com/seike460/s3ry/pkg/interfaces"
)

// Interface implementation methods for Client - MVP Basic Operations Only

// wrapError provides basic error wrapping for MVP
func (c *Client) wrapError(err error, operation string) error {
	if err == nil {
		return nil
	}
	return fmt.Errorf("%s failed: %w", operation, err)
}

// ListBuckets implements the interfaces.S3Client interface
func (c *Client) ListBuckets(ctx context.Context) ([]interfaces.BucketInfo, error) {
	result, err := c.s3Client.ListBucketsWithContext(ctx, &s3.ListBucketsInput{})
	if err != nil {
		return nil, c.wrapError(err, "ListBuckets")
	}

	buckets := make([]interfaces.BucketInfo, len(result.Buckets))
	for i, bucket := range result.Buckets {
		buckets[i] = interfaces.BucketInfo{
			Name:    aws.StringValue(bucket.Name),
			Created: aws.TimeValue(bucket.CreationDate),
		}
	}

	return buckets, nil
}

// ListObjects implements the interfaces.S3Client interface
func (c *Client) ListObjects(ctx context.Context, bucket, prefix, delimiter string) ([]interfaces.ObjectInfo, error) {
	input := &s3.ListObjectsV2Input{
		Bucket: aws.String(bucket),
		Prefix: aws.String(prefix),
	}

	result, err := c.s3Client.ListObjectsV2WithContext(ctx, input)
	if err != nil {
		return nil, c.wrapError(err, "ListObjects")
	}

	objects := make([]interfaces.ObjectInfo, len(result.Contents))
	for i, obj := range result.Contents {
		objects[i] = interfaces.ObjectInfo{
			Key:          aws.StringValue(obj.Key),
			Size:         aws.Int64Value(obj.Size),
			LastModified: aws.TimeValue(obj.LastModified),
			ETag:         strings.Trim(aws.StringValue(obj.ETag), "\""),
		}
	}

	return objects, nil
}

// UploadFile implements the interfaces.S3Client interface
func (c *Client) UploadFile(ctx context.Context, localPath, bucket, key string) error {
	file, err := os.Open(localPath)
	if err != nil {
		return c.wrapAWSError(err, "UploadFile", map[string]interface{}{
			"local_path": localPath,
			"bucket":     bucket,
			"key":        key,
		})
	}
	defer file.Close()

	_, err = c.uploader.UploadWithContext(ctx, &s3manager.UploadInput{
		Bucket: aws.String(bucket),
		Key:    aws.String(key),
		Body:   file,
	})

	if err != nil {
		return c.wrapAWSError(err, "UploadFile", map[string]interface{}{
			"local_path": localPath,
			"bucket":     bucket,
			"key":        key,
		})
	}

	return nil
}

// DownloadFile implements the interfaces.S3Client interface
func (c *Client) DownloadFile(ctx context.Context, bucket, key, localPath string) error {
	file, err := os.Create(localPath)
	if err != nil {
		return c.wrapAWSError(err, "DownloadFile", map[string]interface{}{
			"bucket":     bucket,
			"key":        key,
			"local_path": localPath,
		})
	}
	defer file.Close()

	_, err = c.downloader.DownloadWithContext(ctx, file, &s3.GetObjectInput{
		Bucket: aws.String(bucket),
		Key:    aws.String(key),
	})

	if err != nil {
		return c.wrapAWSError(err, "DownloadFile", map[string]interface{}{
			"bucket":     bucket,
			"key":        key,
			"local_path": localPath,
		})
	}

	return nil
}

// DeleteObject implements the interfaces.S3Client interface
func (c *Client) DeleteObject(ctx context.Context, bucket, key string) error {
	_, err := c.s3Client.DeleteObjectWithContext(ctx, &s3.DeleteObjectInput{
		Bucket: aws.String(bucket),
		Key:    aws.String(key),
	})

	if err != nil {
		return c.wrapAWSError(err, "DeleteObject", map[string]interface{}{
			"bucket": bucket,
			"key":    key,
		})
	}

	return nil
}

// GetBucketRegion method already exists in client.go - no need to redefine

// Extended operations for API compatibility

// CreateBucket implements the interfaces.S3Client interface
func (c *Client) CreateBucket(ctx context.Context, bucket string) error {
	_, err := c.s3Client.CreateBucketWithContext(ctx, &s3.CreateBucketInput{
		Bucket: aws.String(bucket),
	})
	
	if err != nil {
		return c.wrapAWSError(err, "CreateBucket", map[string]interface{}{
			"bucket": bucket,
		})
	}
	
	return nil
}

// DeleteBucket implements the interfaces.S3Client interface
func (c *Client) DeleteBucket(ctx context.Context, bucket string) error {
	_, err := c.s3Client.DeleteBucketWithContext(ctx, &s3.DeleteBucketInput{
		Bucket: aws.String(bucket),
	})
	
	if err != nil {
		return c.wrapAWSError(err, "DeleteBucket", map[string]interface{}{
			"bucket": bucket,
		})
	}
	
	return nil
}

// GetBucketInfo implements the interfaces.S3Client interface
func (c *Client) GetBucketInfo(ctx context.Context, bucket string) (*interfaces.BucketInfo, error) {
	// Get bucket location
	locationResp, err := c.s3Client.GetBucketLocationWithContext(ctx, &s3.GetBucketLocationInput{
		Bucket: aws.String(bucket),
	})
	if err != nil {
		return nil, c.wrapAWSError(err, "GetBucketInfo", map[string]interface{}{
			"bucket": bucket,
		})
	}

	region := aws.StringValue(locationResp.LocationConstraint)
	if region == "" {
		region = "us-east-1" // Default region for empty location constraint
	}

	// Get bucket creation date from list buckets
	buckets, err := c.ListBuckets(ctx)
	if err != nil {
		return nil, err
	}

	for _, b := range buckets {
		if b.Name == bucket {
			return &interfaces.BucketInfo{
				Name:   bucket,
				Region: region,
				Created: b.Created,
			}, nil
		}
	}

	return nil, fmt.Errorf("bucket %s not found", bucket)
}

// ListObjectsWithLimit implements the interfaces.S3Client interface
func (c *Client) ListObjectsWithLimit(ctx context.Context, bucket, prefix string, maxKeys int) (*interfaces.ObjectList, error) {
	input := &s3.ListObjectsV2Input{
		Bucket:  aws.String(bucket),
		Prefix:  aws.String(prefix),
		MaxKeys: aws.Int64(int64(maxKeys)),
	}

	result, err := c.s3Client.ListObjectsV2WithContext(ctx, input)
	if err != nil {
		return nil, c.wrapAWSError(err, "ListObjectsWithLimit", map[string]interface{}{
			"bucket":  bucket,
			"prefix":  prefix,
			"maxKeys": maxKeys,
		})
	}

	objects := make([]interfaces.ObjectInfo, len(result.Contents))
	for i, obj := range result.Contents {
		objects[i] = interfaces.ObjectInfo{
			Key:          aws.StringValue(obj.Key),
			Size:         aws.Int64Value(obj.Size),
			LastModified: aws.TimeValue(obj.LastModified),
			ETag:         strings.Trim(aws.StringValue(obj.ETag), "\""),
		}
	}

	return &interfaces.ObjectList{
		Objects:               objects,
		IsTruncated:           aws.BoolValue(result.IsTruncated),
		NextContinuationToken: aws.StringValue(result.NextContinuationToken),
	}, nil
}

// UploadObject implements the interfaces.S3Client interface
func (c *Client) UploadObject(ctx context.Context, bucket, key string, content []byte) (*interfaces.PutResult, error) {
	_, err := c.s3Client.PutObjectWithContext(ctx, &s3.PutObjectInput{
		Bucket: aws.String(bucket),
		Key:    aws.String(key),
		Body:   strings.NewReader(string(content)),
	})

	if err != nil {
		return nil, c.wrapAWSError(err, "UploadObject", map[string]interface{}{
			"bucket": bucket,
			"key":    key,
		})
	}

	return &interfaces.PutResult{
		ETag: "uploaded", // Simplified for MVP
	}, nil
}

// GetPresignedURL implements the interfaces.S3Client interface  
func (c *Client) GetPresignedURL(ctx context.Context, bucket, key string, expires time.Duration) (string, error) {
	req, _ := c.s3Client.GetObjectRequest(&s3.GetObjectInput{
		Bucket: aws.String(bucket),
		Key:    aws.String(key),
	})

	url, err := req.Presign(expires)
	if err != nil {
		return "", c.wrapAWSError(err, "GetPresignedURL", map[string]interface{}{
			"bucket":  bucket,
			"key":     key,
			"expires": expires,
		})
	}

	return url, nil
}

// StreamObject implements the interfaces.S3Client interface
func (c *Client) StreamObject(ctx context.Context, bucket, key string) (*interfaces.Object, error) {
	result, err := c.s3Client.GetObjectWithContext(ctx, &s3.GetObjectInput{
		Bucket: aws.String(bucket),
		Key:    aws.String(key),
	})

	if err != nil {
		return nil, c.wrapAWSError(err, "StreamObject", map[string]interface{}{
			"bucket": bucket,
			"key":    key,
		})
	}

	// Read all content for MVP - in production this would be streaming
	content := make([]byte, aws.Int64Value(result.ContentLength))
	_, err = result.Body.Read(content)
	result.Body.Close()

	if err != nil {
		return nil, err
	}

	return &interfaces.Object{
		Info: &interfaces.ObjectInfo{
			Key:          key,
			Size:         aws.Int64Value(result.ContentLength),
			LastModified: aws.TimeValue(result.LastModified),
			ETag:         strings.Trim(aws.StringValue(result.ETag), "\""),
		},
		Content: content,
	}, nil
}

// GetObjectMetadata implements the interfaces.S3Client interface
func (c *Client) GetObjectMetadata(ctx context.Context, bucket, key string) (*interfaces.ObjectMetadata, error) {
	result, err := c.s3Client.HeadObjectWithContext(ctx, &s3.HeadObjectInput{
		Bucket: aws.String(bucket),
		Key:    aws.String(key),
	})

	if err != nil {
		return nil, c.wrapAWSError(err, "GetObjectMetadata", map[string]interface{}{
			"bucket": bucket,
			"key":    key,
		})
	}

	return &interfaces.ObjectMetadata{
		Key:          key,
		Size:         aws.Int64Value(result.ContentLength),
		LastModified: aws.TimeValue(result.LastModified),
		ContentType:  aws.StringValue(result.ContentType),
		Metadata:     result.Metadata,
	}, nil
}