package errors

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/seike460/s3ry/internal/config"
	"github.com/seike460/s3ry/internal/logging"
)

// UnifiedErrorHandler combines all error handling capabilities into one high-performance handler
type UnifiedErrorHandler struct {
	// Core components
	config       *config.Config
	logger       *logging.Logger
	tracker      *AdvancedErrorTracker
	
	// High-performance pattern matching using sync.Map for concurrent access
	patterns     sync.Map // map[string]*ErrorPattern
	recoverers   sync.Map // map[ErrorType]RecoveryFunc
	interceptors []ErrorInterceptor
	
	// Performance optimized metrics with atomic operations
	metrics      *UnifiedErrorMetrics
	
	// Memory pools for reducing GC pressure
	errorPool    sync.Pool
	contextPool  sync.Pool
	
	// Circuit breaker for error recovery
	circuitBreaker *CircuitBreaker
	
	// Context management
	ctx          context.Context
	cancel       context.CancelFunc
	running      int64
}

// UnifiedErrorMetrics provides atomic performance metrics
type UnifiedErrorMetrics struct {
	// Atomic counters for thread-safe operations
	TotalErrors      int64 `json:"total_errors"`
	RecoveredErrors  int64 `json:"recovered_errors"`
	HandlingTime     int64 `json:"avg_handling_time_ns"`
	
	// Error categorization counters
	NetworkErrors    int64 `json:"network_errors"`
	AuthErrors       int64 `json:"auth_errors"`
	PermissionErrors int64 `json:"permission_errors"`
	ValidationErrors int64 `json:"validation_errors"`
	S3Errors         int64 `json:"s3_errors"`
	InternalErrors   int64 `json:"internal_errors"`
	
	// Performance metrics
	HandlingLatency  int64 `json:"handling_latency_ns"`
	RecoverySuccess  int64 `json:"recovery_success_rate"`
	PatternMatches   int64 `json:"pattern_matches"`
	
	// Last update timestamp
	LastUpdate       int64 `json:"last_update"`
}

// CircuitBreaker prevents cascading failures in error recovery
type CircuitBreaker struct {
	mu           sync.RWMutex
	state        CircuitState
	failures     int64
	successes    int64
	lastFailTime time.Time
	threshold    int
	timeout      time.Duration
}

type CircuitState int

const (
	CircuitClosed CircuitState = iota
	CircuitOpen
	CircuitHalfOpen
)

// NewUnifiedErrorHandler creates a new high-performance unified error handler
func NewUnifiedErrorHandler(cfg *config.Config, logger *logging.Logger) *UnifiedErrorHandler {
	ctx, cancel := context.WithCancel(context.Background())
	
	handler := &UnifiedErrorHandler{
		config:  cfg,
		logger:  logger,
		tracker: NewAdvancedErrorTracker(cfg),
		metrics: &UnifiedErrorMetrics{},
		circuitBreaker: &CircuitBreaker{
			state:     CircuitClosed,
			threshold: 10,
			timeout:   30 * time.Second,
		},
		ctx:    ctx,
		cancel: cancel,
	}
	
	// Initialize memory pools for zero-allocation error handling
	handler.initializePools()
	
	// Load optimized error patterns
	handler.loadOptimizedPatterns()
	
	// Initialize high-performance recoverers
	handler.initializeRecoverers()
	
	// Start background metrics collection
	go handler.metricsCollector()
	
	atomic.StoreInt64(&handler.running, 1)
	
	return handler
}

// initializePools sets up memory pools for zero-allocation operations
func (h *UnifiedErrorHandler) initializePools() {
	h.errorPool = sync.Pool{
		New: func() interface{} {
			return &S3ryError{
				Context:   make(map[string]interface{}, 8),
				Timestamp: time.Now(),
			}
		},
	}
	
	h.contextPool = sync.Pool{
		New: func() interface{} {
			return make(map[string]interface{}, 8)
		},
	}
}

// HandleError processes errors with maximum performance optimization
func (h *UnifiedErrorHandler) HandleError(ctx context.Context, err error, operation, component string) *S3ryError {
	if err == nil {
		return nil
	}
	
	startTime := time.Now()
	
	// Fast path for S3ryError
	if s3ryErr, ok := err.(*S3ryError); ok {
		h.updateMetricsAtomic(s3ryErr, time.Since(startTime))
		return s3ryErr
	}
	
	// Get error from pool for zero allocation
	s3ryErr := h.getErrorFromPool()
	defer h.putErrorToPool(s3ryErr)
	
	// Fast error classification
	h.classifyErrorFast(s3ryErr, err, operation, component)
	
	// High-performance pattern matching
	h.matchPatternsOptimized(s3ryErr)
	
	// AWS-specific optimization
	if awsErr, ok := err.(awserr.Error); ok {
		h.handleAWSErrorOptimized(s3ryErr, awsErr)
	}
	
	// Apply interceptors (minimal overhead)
	for _, interceptor := range h.interceptors {
		s3ryErr = interceptor(s3ryErr)
	}
	
	// Update metrics atomically
	handlingTime := time.Since(startTime)
	h.updateMetricsAtomic(s3ryErr, handlingTime)
	
	// Async logging for performance
	go h.logErrorAsync(s3ryErr)
	
	// Async tracking for performance
	if h.tracker != nil {
		go h.trackErrorAsync(s3ryErr)
	}
	
	return s3ryErr
}

// classifyErrorFast performs ultra-fast error classification
func (h *UnifiedErrorHandler) classifyErrorFast(s3ryErr *S3ryError, err error, operation, component string) {
	message := err.Error()
	msgLower := strings.ToLower(message)
	
	// Reset error object
	s3ryErr.Code = ""
	s3ryErr.Message = message
	s3ryErr.Operation = operation
	s3ryErr.Component = component
	s3ryErr.Cause = err
	s3ryErr.Timestamp = time.Now()
	s3ryErr.Recoverable = false
	s3ryErr.Severity = SeverityLow
	s3ryErr.Type = ErrorTypeUnknown
	
	// Ultra-fast pattern matching using switch for common cases
	switch {
	case strings.Contains(msgLower, "network") || strings.Contains(msgLower, "connection"):
		s3ryErr.Type = ErrorTypeNetwork
		s3ryErr.Severity = SeverityMedium
		s3ryErr.Recoverable = true
		s3ryErr.Code = "NETWORK_ERROR"
		atomic.AddInt64(&h.metrics.NetworkErrors, 1)
		
	case strings.Contains(msgLower, "access") && strings.Contains(msgLower, "denied"):
		s3ryErr.Type = ErrorTypePermission
		s3ryErr.Severity = SeverityHigh
		s3ryErr.Code = "PERMISSION_DENIED"
		atomic.AddInt64(&h.metrics.PermissionErrors, 1)
		
	case strings.Contains(msgLower, "credentials") || strings.Contains(msgLower, "signature"):
		s3ryErr.Type = ErrorTypeAuthentication
		s3ryErr.Severity = SeverityHigh
		s3ryErr.Code = "AUTH_ERROR"
		atomic.AddInt64(&h.metrics.AuthErrors, 1)
		
	case strings.Contains(msgLower, "timeout"):
		s3ryErr.Type = ErrorTypeTimeout
		s3ryErr.Severity = SeverityMedium
		s3ryErr.Recoverable = true
		s3ryErr.Code = "TIMEOUT_ERROR"
		
	case strings.Contains(msgLower, "rate") || strings.Contains(msgLower, "throttle"):
		s3ryErr.Type = ErrorTypeRateLimit
		s3ryErr.Severity = SeverityMedium
		s3ryErr.Recoverable = true
		s3ryErr.RetryAfter = 5 * time.Second
		s3ryErr.Code = "RATE_LIMIT"
		
	case strings.Contains(msgLower, "not found") || strings.Contains(msgLower, "does not exist"):
		s3ryErr.Type = ErrorTypeNotFound
		s3ryErr.Severity = SeverityMedium
		s3ryErr.Code = "NOT_FOUND"
		
	case strings.Contains(msgLower, "validation") || strings.Contains(msgLower, "invalid"):
		s3ryErr.Type = ErrorTypeValidation
		s3ryErr.Severity = SeverityMedium
		s3ryErr.Code = "VALIDATION_ERROR"
		atomic.AddInt64(&h.metrics.ValidationErrors, 1)
		
	default:
		s3ryErr.Type = ErrorTypeInternal
		s3ryErr.Severity = SeverityLow
		s3ryErr.Code = "INTERNAL_ERROR"
		atomic.AddInt64(&h.metrics.InternalErrors, 1)
	}
}

// handleAWSErrorOptimized provides optimized AWS error handling
func (h *UnifiedErrorHandler) handleAWSErrorOptimized(s3ryErr *S3ryError, awsErr awserr.Error) {
	code := awsErr.Code()
	s3ryErr.Code = code
	
	// Get context from pool
	if s3ryErr.Context == nil {
		s3ryErr.Context = h.getContextFromPool()
	}
	
	s3ryErr.Context["aws_error_code"] = code
	s3ryErr.Context["aws_error_message"] = awsErr.Message()
	
	if reqErr, ok := awsErr.(awserr.RequestFailure); ok {
		s3ryErr.Context["aws_status_code"] = reqErr.StatusCode()
		s3ryErr.Context["aws_request_id"] = reqErr.RequestID()
		s3ryErr.RequestID = reqErr.RequestID()
	}
	
	// Fast AWS error classification
	switch {
	case strings.HasPrefix(code, "NoSuch"):
		s3ryErr.Type = ErrorTypeNotFound
		s3ryErr.Severity = SeverityMedium
	case code == "AccessDenied" || code == "Forbidden":
		s3ryErr.Type = ErrorTypePermission
		s3ryErr.Severity = SeverityHigh
	case code == "InvalidAccessKeyId" || code == "SignatureDoesNotMatch":
		s3ryErr.Type = ErrorTypeAuthentication
		s3ryErr.Severity = SeverityHigh
	case code == "SlowDown" || code == "RequestLimitExceeded":
		s3ryErr.Type = ErrorTypeRateLimit
		s3ryErr.Severity = SeverityMedium
		s3ryErr.Recoverable = true
		s3ryErr.RetryAfter = 5 * time.Second
	case code == "ServiceUnavailable" || code == "InternalError":
		s3ryErr.Type = ErrorTypeNetwork
		s3ryErr.Severity = SeverityHigh
		s3ryErr.Recoverable = true
	default:
		s3ryErr.Type = ErrorTypeInternal
		atomic.AddInt64(&h.metrics.S3Errors, 1)
	}
}

// matchPatternsOptimized performs high-performance pattern matching
func (h *UnifiedErrorHandler) matchPatternsOptimized(s3ryErr *S3ryError) {
	// Use sync.Map for lock-free reads in concurrent scenarios
	if pattern, ok := h.patterns.Load(string(s3ryErr.Type)); ok {
		if p, ok := pattern.(*ErrorPattern); ok {
			s3ryErr.Recoverable = p.Retryable
			s3ryErr.RetryAfter = p.RetryDelay
			s3ryErr.Suggestions = p.Suggestions
			s3ryErr.HelpURL = p.HelpURL
			atomic.AddInt64(&h.metrics.PatternMatches, 1)
		}
	}
}

// RecoverWithCircuitBreaker attempts error recovery with circuit breaker protection
func (h *UnifiedErrorHandler) RecoverWithCircuitBreaker(ctx context.Context, s3ryErr *S3ryError) error {
	if !s3ryErr.Recoverable {
		return fmt.Errorf("error is not recoverable: %w", s3ryErr)
	}
	
	// Check circuit breaker state
	if !h.circuitBreaker.CanExecute() {
		return fmt.Errorf("circuit breaker is open, recovery skipped")
	}
	
	if recoverer, ok := h.recoverers.Load(s3ryErr.Type); ok {
		if recoverFunc, ok := recoverer.(RecoveryFunc); ok {
			startTime := time.Now()
			
			err := recoverFunc(ctx, s3ryErr)
			
			if err != nil {
				h.circuitBreaker.RecordFailure()
				return err
			}
			
			h.circuitBreaker.RecordSuccess()
			atomic.AddInt64(&h.metrics.RecoveredErrors, 1)
			
			// Update recovery success rate
			recoveryTime := time.Since(startTime)
			atomic.AddInt64(&h.metrics.RecoverySuccess, int64(recoveryTime))
			
			return nil
		}
	}
	
	return fmt.Errorf("no recovery function available for error type: %s", s3ryErr.Type)
}

// updateMetricsAtomic updates metrics using atomic operations for thread safety
func (h *UnifiedErrorHandler) updateMetricsAtomic(s3ryErr *S3ryError, handlingTime time.Duration) {
	atomic.AddInt64(&h.metrics.TotalErrors, 1)
	atomic.StoreInt64(&h.metrics.HandlingLatency, int64(handlingTime))
	atomic.StoreInt64(&h.metrics.LastUpdate, time.Now().UnixNano())
	
	// Update average handling time using exponential moving average
	currentAvg := atomic.LoadInt64(&h.metrics.HandlingTime)
	newAvg := int64(0.9*float64(currentAvg) + 0.1*float64(handlingTime))
	atomic.StoreInt64(&h.metrics.HandlingTime, newAvg)
}

// Pool management for zero-allocation operations
func (h *UnifiedErrorHandler) getErrorFromPool() *S3ryError {
	return h.errorPool.Get().(*S3ryError)
}

func (h *UnifiedErrorHandler) putErrorToPool(err *S3ryError) {
	// Reset error for reuse
	err.Code = ""
	err.Message = ""
	err.Details = ""
	err.Cause = nil
	err.Context = nil
	err.StackTrace = nil
	err.Retryable = false
	err.RetryAfter = 0
	err.Suggestions = nil
	err.HelpURL = ""
	
	h.errorPool.Put(err)
}

func (h *UnifiedErrorHandler) getContextFromPool() map[string]interface{} {
	ctx := h.contextPool.Get().(map[string]interface{})
	// Clear the map
	for k := range ctx {
		delete(ctx, k)
	}
	return ctx
}

func (h *UnifiedErrorHandler) putContextToPool(ctx map[string]interface{}) {
	h.contextPool.Put(ctx)
}

// Async operations for performance
func (h *UnifiedErrorHandler) logErrorAsync(s3ryErr *S3ryError) {
	fields := []interface{}{
		"error_code", s3ryErr.Code,
		"error_type", string(s3ryErr.Type),
		"severity", string(s3ryErr.Severity),
		"operation", s3ryErr.Operation,
		"component", s3ryErr.Component,
		"recoverable", s3ryErr.Recoverable,
	}
	
	switch s3ryErr.Severity {
	case SeverityCritical, SeverityHigh:
		h.logger.Error(s3ryErr.Message, s3ryErr.Cause, fields...)
	case SeverityMedium:
		h.logger.Warn(s3ryErr.Message, fields...)
	default:
		h.logger.Info(s3ryErr.Message, fields...)
	}
}

func (h *UnifiedErrorHandler) trackErrorAsync(s3ryErr *S3ryError) {
	if h.tracker == nil {
		return
	}
	
	context := make(map[string]interface{})
	if s3ryErr.Context != nil {
		context = s3ryErr.Context
	}
	context["error_id"] = fmt.Sprintf("unified_%d", time.Now().UnixNano())
	
	h.tracker.TrackError(
		s3ryErr.Operation,
		s3ryErr.Code,
		s3ryErr.Message,
		string(s3ryErr.Type),
		context,
	)
}

// metricsCollector runs in background to collect performance metrics
func (h *UnifiedErrorHandler) metricsCollector() {
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()
	
	for {
		select {
		case <-ticker.C:
			// Update runtime metrics
			var memStats runtime.MemStats
			runtime.ReadMemStats(&memStats)
			
			// Calculate success rates, throughput, etc.
			// This runs asynchronously to avoid blocking error handling
			
		case <-h.ctx.Done():
			return
		}
	}
}

// GetMetrics returns current performance metrics
func (h *UnifiedErrorHandler) GetMetrics() *UnifiedErrorMetrics {
	return &UnifiedErrorMetrics{
		TotalErrors:      atomic.LoadInt64(&h.metrics.TotalErrors),
		RecoveredErrors:  atomic.LoadInt64(&h.metrics.RecoveredErrors),
		HandlingTime:     atomic.LoadInt64(&h.metrics.HandlingTime),
		NetworkErrors:    atomic.LoadInt64(&h.metrics.NetworkErrors),
		AuthErrors:       atomic.LoadInt64(&h.metrics.AuthErrors),
		PermissionErrors: atomic.LoadInt64(&h.metrics.PermissionErrors),
		ValidationErrors: atomic.LoadInt64(&h.metrics.ValidationErrors),
		S3Errors:         atomic.LoadInt64(&h.metrics.S3Errors),
		InternalErrors:   atomic.LoadInt64(&h.metrics.InternalErrors),
		HandlingLatency:  atomic.LoadInt64(&h.metrics.HandlingLatency),
		RecoverySuccess:  atomic.LoadInt64(&h.metrics.RecoverySuccess),
		PatternMatches:   atomic.LoadInt64(&h.metrics.PatternMatches),
		LastUpdate:       atomic.LoadInt64(&h.metrics.LastUpdate),
	}
}

// Close gracefully shuts down the handler
func (h *UnifiedErrorHandler) Close() error {
	if !atomic.CompareAndSwapInt64(&h.running, 1, 0) {
		return fmt.Errorf("handler is not running")
	}
	
	h.cancel()
	
	if h.tracker != nil {
		return h.tracker.Stop()
	}
	
	return nil
}

// Circuit breaker implementation
func (cb *CircuitBreaker) CanExecute() bool {
	cb.mu.RLock()
	defer cb.mu.RUnlock()
	
	switch cb.state {
	case CircuitClosed:
		return true
	case CircuitOpen:
		return time.Since(cb.lastFailTime) > cb.timeout
	case CircuitHalfOpen:
		return true
	default:
		return false
	}
}

func (cb *CircuitBreaker) RecordSuccess() {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	
	atomic.AddInt64(&cb.successes, 1)
	
	if cb.state == CircuitHalfOpen {
		cb.state = CircuitClosed
		atomic.StoreInt64(&cb.failures, 0)
	}
}

func (cb *CircuitBreaker) RecordFailure() {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	
	atomic.AddInt64(&cb.failures, 1)
	cb.lastFailTime = time.Now()
	
	if atomic.LoadInt64(&cb.failures) >= int64(cb.threshold) {
		cb.state = CircuitOpen
	}
}

// loadOptimizedPatterns loads high-performance error patterns
func (h *UnifiedErrorHandler) loadOptimizedPatterns() {
	patterns := map[string]*ErrorPattern{
		string(ErrorTypeNetwork): {
			Type:        ErrorTypeNetwork,
			Severity:    SeverityMedium,
			Retryable:   true,
			RetryDelay:  2 * time.Second,
			Suggestions: []string{"Check network connection", "Verify AWS service status"},
			HelpURL:     "https://docs.aws.amazon.com/general/latest/gr/api-retries.html",
		},
		string(ErrorTypeAuthentication): {
			Type:        ErrorTypeAuthentication,
			Severity:    SeverityHigh,
			Retryable:   false,
			Suggestions: []string{"Check AWS credentials", "Verify access keys"},
			HelpURL:     "https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html",
		},
		string(ErrorTypePermission): {
			Type:        ErrorTypePermission,
			Severity:    SeverityHigh,
			Retryable:   false,
			Suggestions: []string{"Check IAM permissions", "Verify bucket policies"},
			HelpURL:     "https://docs.aws.amazon.com/s3/latest/userguide/access-control-overview.html",
		},
		string(ErrorTypeRateLimit): {
			Type:        ErrorTypeRateLimit,
			Severity:    SeverityMedium,
			Retryable:   true,
			RetryDelay:  5 * time.Second,
			Suggestions: []string{"Reduce request rate", "Implement exponential backoff"},
			HelpURL:     "https://docs.aws.amazon.com/s3/latest/userguide/optimizing-performance.html",
		},
	}
	
	for key, pattern := range patterns {
		h.patterns.Store(key, pattern)
	}
}

// initializeRecoverers sets up high-performance recovery functions
func (h *UnifiedErrorHandler) initializeRecoverers() {
	// Network error recovery with exponential backoff
	h.recoverers.Store(ErrorTypeNetwork, RecoveryFunc(func(ctx context.Context, err *S3ryError) error {
		for i := 0; i < 3; i++ {
			select {
			case <-ctx.Done():
				return ctx.Err()
			case <-time.After(time.Duration(1<<uint(i)) * time.Second):
				// In real implementation, retry the original operation
				return nil
			}
		}
		return fmt.Errorf("network recovery failed")
	}))
	
	// Rate limit recovery
	h.recoverers.Store(ErrorTypeRateLimit, RecoveryFunc(func(ctx context.Context, err *S3ryError) error {
		delay := err.RetryAfter
		if delay == 0 {
			delay = 5 * time.Second
		}
		
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(delay):
			return nil
		}
	}))
}