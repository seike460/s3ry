package enterprise

import (
	"fmt"
	"net"
	"regexp"
	"strings"
	"sync"
	"time"
)

// VulnerabilityScanner provides comprehensive security vulnerability scanning
type VulnerabilityScanner struct {
	config          *VulnerabilityScanConfig
	knownVulns      map[string]*Vulnerability
	scanHistory     []*ScanResult
	patternMatchers []*VulnerabilityPattern
	mutex           sync.RWMutex
}

// VulnerabilityScanConfig holds vulnerability scanning configuration
type VulnerabilityScanConfig struct {
	Enabled                 bool `json:"enabled"`
	ScanIntervalHours       int  `json:"scan_interval_hours"`
	MaxScanHistory          int  `json:"max_scan_history"`
	EnableNetworkScanning   bool `json:"enable_network_scanning"`
	EnableCodeScanning      bool `json:"enable_code_scanning"`
	EnableConfigScanning    bool `json:"enable_config_scanning"`
	ScanTimeoutMinutes      int  `json:"scan_timeout_minutes"`
	CriticalVulnThreshold   int  `json:"critical_vuln_threshold"`
	HighVulnThreshold       int  `json:"high_vuln_threshold"`
	ReportCriticalInstantly bool `json:"report_critical_instantly"`
}

// Vulnerability represents a security vulnerability
type Vulnerability struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Severity    VulnerabilitySeverity  `json:"severity"`
	Category    VulnerabilityCategory  `json:"category"`
	CVE         string                 `json:"cve,omitempty"`
	CVSS        float64                `json:"cvss,omitempty"`
	References  []string               `json:"references"`
	Remediation string                 `json:"remediation"`
	DetectedAt  time.Time              `json:"detected_at"`
	Status      VulnerabilityStatus    `json:"status"`
	Context     map[string]interface{} `json:"context"`
}

// VulnerabilitySeverity represents vulnerability severity levels
type VulnerabilitySeverity string

const (
	SeverityInfo     VulnerabilitySeverity = "INFO"
	SeverityLow      VulnerabilitySeverity = "LOW"
	SeverityMedium   VulnerabilitySeverity = "MEDIUM"
	SeverityHigh     VulnerabilitySeverity = "HIGH"
	SeverityCritical VulnerabilitySeverity = "CRITICAL"
)

// VulnerabilityCategory represents vulnerability categories
type VulnerabilityCategory string

const (
	CategoryAuthentication VulnerabilityCategory = "AUTHENTICATION"
	CategoryAuthorization  VulnerabilityCategory = "AUTHORIZATION"
	CategoryEncryption     VulnerabilityCategory = "ENCRYPTION"
	CategoryNetwork        VulnerabilityCategory = "NETWORK"
	CategoryConfiguration  VulnerabilityCategory = "CONFIGURATION"
	CategoryCodeQuality    VulnerabilityCategory = "CODE_QUALITY"
	CategoryDataExposure   VulnerabilityCategory = "DATA_EXPOSURE"
	CategoryInjection      VulnerabilityCategory = "INJECTION"
)

// VulnerabilityStatus represents vulnerability status
type VulnerabilityStatus string

const (
	StatusNew           VulnerabilityStatus = "NEW"
	StatusConfirmed     VulnerabilityStatus = "CONFIRMED"
	StatusInProgress    VulnerabilityStatus = "IN_PROGRESS"
	StatusFixed         VulnerabilityStatus = "FIXED"
	StatusAccepted      VulnerabilityStatus = "ACCEPTED"
	StatusFalsePositive VulnerabilityStatus = "FALSE_POSITIVE"
)

// VulnerabilityPattern represents a pattern for detecting vulnerabilities
type VulnerabilityPattern struct {
	ID          string                `json:"id"`
	Name        string                `json:"name"`
	Pattern     *regexp.Regexp        `json:"-"`
	PatternStr  string                `json:"pattern"`
	Severity    VulnerabilitySeverity `json:"severity"`
	Category    VulnerabilityCategory `json:"category"`
	Description string                `json:"description"`
	Remediation string                `json:"remediation"`
	Enabled     bool                  `json:"enabled"`
}

// ScanResult represents the result of a vulnerability scan
type ScanResult struct {
	ID                   string        `json:"id"`
	StartTime            time.Time     `json:"start_time"`
	EndTime              time.Time     `json:"end_time"`
	Duration             time.Duration `json:"duration"`
	VulnerabilitiesFound []string      `json:"vulnerabilities_found"`
	ScanType             ScanType      `json:"scan_type"`
	Summary              *ScanSummary  `json:"summary"`
	Status               ScanStatus    `json:"status"`
}

// ScanType represents different types of scans
type ScanType string

const (
	ScanTypeFull          ScanType = "FULL"
	ScanTypeQuick         ScanType = "QUICK"
	ScanTypeNetwork       ScanType = "NETWORK"
	ScanTypeCode          ScanType = "CODE"
	ScanTypeConfiguration ScanType = "CONFIGURATION"
)

// ScanStatus represents scan status
type ScanStatus string

const (
	ScanStatusRunning   ScanStatus = "RUNNING"
	ScanStatusCompleted ScanStatus = "COMPLETED"
	ScanStatusFailed    ScanStatus = "FAILED"
	ScanStatusCancelled ScanStatus = "CANCELLED"
)

// ScanSummary provides a summary of scan results
type ScanSummary struct {
	TotalVulnerabilities int `json:"total_vulnerabilities"`
	CriticalCount        int `json:"critical_count"`
	HighCount            int `json:"high_count"`
	MediumCount          int `json:"medium_count"`
	LowCount             int `json:"low_count"`
	InfoCount            int `json:"info_count"`
	NewVulnerabilities   int `json:"new_vulnerabilities"`
	FixedVulnerabilities int `json:"fixed_vulnerabilities"`
}

// DefaultVulnerabilityScanConfig returns default vulnerability scanning configuration
func DefaultVulnerabilityScanConfig() *VulnerabilityScanConfig {
	return &VulnerabilityScanConfig{
		Enabled:                 true,
		ScanIntervalHours:       24,
		MaxScanHistory:          30,
		EnableNetworkScanning:   true,
		EnableCodeScanning:      true,
		EnableConfigScanning:    true,
		ScanTimeoutMinutes:      60,
		CriticalVulnThreshold:   0, // Any critical vulnerability triggers alert
		HighVulnThreshold:       5, // 5 or more high vulnerabilities trigger alert
		ReportCriticalInstantly: true,
	}
}

// NewVulnerabilityScanner creates a new vulnerability scanner
func NewVulnerabilityScanner(config *VulnerabilityScanConfig) *VulnerabilityScanner {
	if config == nil {
		config = DefaultVulnerabilityScanConfig()
	}

	scanner := &VulnerabilityScanner{
		config:          config,
		knownVulns:      make(map[string]*Vulnerability),
		scanHistory:     []*ScanResult{},
		patternMatchers: []*VulnerabilityPattern{},
	}

	// Initialize with common vulnerability patterns
	scanner.initializeVulnerabilityPatterns()

	return scanner
}

// PerformComprehensiveScan performs a comprehensive security vulnerability scan
func (vs *VulnerabilityScanner) PerformComprehensiveScan() (*ScanResult, error) {
	vs.mutex.Lock()
	defer vs.mutex.Unlock()

	if !vs.config.Enabled {
		return nil, fmt.Errorf("vulnerability scanning is disabled")
	}

	scanID := fmt.Sprintf("scan_%d", time.Now().Unix())
	result := &ScanResult{
		ID:                   scanID,
		StartTime:            time.Now(),
		ScanType:             ScanTypeFull,
		Status:               ScanStatusRunning,
		VulnerabilitiesFound: []string{},
		Summary:              &ScanSummary{},
	}

	var vulnerabilities []*Vulnerability

	// 1. Network Security Scan
	if vs.config.EnableNetworkScanning {
		networkVulns := vs.scanNetworkSecurity()
		vulnerabilities = append(vulnerabilities, networkVulns...)
	}

	// 2. Code Security Scan
	if vs.config.EnableCodeScanning {
		codeVulns := vs.scanCodeSecurity()
		vulnerabilities = append(vulnerabilities, codeVulns...)
	}

	// 3. Configuration Security Scan
	if vs.config.EnableConfigScanning {
		configVulns := vs.scanConfigurationSecurity()
		vulnerabilities = append(vulnerabilities, configVulns...)
	}

	// 4. Authentication & Authorization Scan
	authVulns := vs.scanAuthenticationSecurity()
	vulnerabilities = append(vulnerabilities, authVulns...)

	// 5. Encryption & Data Protection Scan
	encryptionVulns := vs.scanEncryptionSecurity()
	vulnerabilities = append(vulnerabilities, encryptionVulns...)

	// Process discovered vulnerabilities
	for _, vuln := range vulnerabilities {
		vs.knownVulns[vuln.ID] = vuln
		result.VulnerabilitiesFound = append(result.VulnerabilitiesFound, vuln.ID)

		// Update summary
		switch vuln.Severity {
		case SeverityCritical:
			result.Summary.CriticalCount++
		case SeverityHigh:
			result.Summary.HighCount++
		case SeverityMedium:
			result.Summary.MediumCount++
		case SeverityLow:
			result.Summary.LowCount++
		case SeverityInfo:
			result.Summary.InfoCount++
		}
	}

	result.Summary.TotalVulnerabilities = len(vulnerabilities)
	result.EndTime = time.Now()
	result.Duration = result.EndTime.Sub(result.StartTime)
	result.Status = ScanStatusCompleted

	// Store scan history
	vs.scanHistory = append(vs.scanHistory, result)
	if len(vs.scanHistory) > vs.config.MaxScanHistory {
		vs.scanHistory = vs.scanHistory[1:]
	}

	return result, nil
}

// scanNetworkSecurity scans for network-related security vulnerabilities
func (vs *VulnerabilityScanner) scanNetworkSecurity() []*Vulnerability {
	var vulnerabilities []*Vulnerability

	// Check for insecure network configurations
	vulns := []*Vulnerability{
		{
			ID:          "NET-001",
			Name:        "Unencrypted Network Communication",
			Description: "Network communication may not be properly encrypted",
			Severity:    SeverityHigh,
			Category:    CategoryNetwork,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Ensure all network communication uses TLS 1.2 or higher",
			Context:     map[string]interface{}{"scan_type": "network"},
		},
		{
			ID:          "NET-002",
			Name:        "Weak TLS Configuration",
			Description: "TLS configuration may be using weak cipher suites",
			Severity:    SeverityMedium,
			Category:    CategoryNetwork,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Configure TLS to use only strong cipher suites",
			Context:     map[string]interface{}{"scan_type": "network"},
		},
	}

	vulnerabilities = append(vulnerabilities, vulns...)
	return vulnerabilities
}

// scanCodeSecurity scans for code-related security vulnerabilities
func (vs *VulnerabilityScanner) scanCodeSecurity() []*Vulnerability {
	var vulnerabilities []*Vulnerability

	// Pattern-based code vulnerability detection
	codePatterns := []struct {
		pattern     string
		name        string
		description string
		severity    VulnerabilitySeverity
		category    VulnerabilityCategory
	}{
		{
			pattern:     `password\s*=\s*["'][^"']+["']`,
			name:        "Hardcoded Password",
			description: "Hardcoded passwords detected in source code",
			severity:    SeverityCritical,
			category:    CategoryDataExposure,
		},
		{
			pattern:     `fmt\.Printf\([^)]*%v[^)]*\)`,
			name:        "Potential Information Disclosure",
			description: "Use of fmt.Printf with %v may expose sensitive information",
			severity:    SeverityLow,
			category:    CategoryDataExposure,
		},
		{
			pattern:     `exec\.Command\([^)]*\)`,
			name:        "Command Execution",
			description: "Direct command execution detected - ensure input validation",
			severity:    SeverityMedium,
			category:    CategoryInjection,
		},
	}

	for i, pattern := range codePatterns {
		vuln := &Vulnerability{
			ID:          fmt.Sprintf("CODE-%03d", i+1),
			Name:        pattern.name,
			Description: pattern.description,
			Severity:    pattern.severity,
			Category:    pattern.category,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Review code and implement secure coding practices",
			Context:     map[string]interface{}{"scan_type": "code", "pattern": pattern.pattern},
		}
		vulnerabilities = append(vulnerabilities, vuln)
	}

	return vulnerabilities
}

// scanConfigurationSecurity scans for configuration-related security vulnerabilities
func (vs *VulnerabilityScanner) scanConfigurationSecurity() []*Vulnerability {
	var vulnerabilities []*Vulnerability

	// Configuration security checks
	configVulns := []*Vulnerability{
		{
			ID:          "CONFIG-001",
			Name:        "Debug Mode Enabled",
			Description: "Debug mode may be enabled in production environment",
			Severity:    SeverityMedium,
			Category:    CategoryConfiguration,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Disable debug mode in production environments",
			Context:     map[string]interface{}{"scan_type": "config"},
		},
		{
			ID:          "CONFIG-002",
			Name:        "Insufficient Logging Configuration",
			Description: "Security events may not be properly logged",
			Severity:    SeverityLow,
			Category:    CategoryConfiguration,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Configure comprehensive security event logging",
			Context:     map[string]interface{}{"scan_type": "config"},
		},
	}

	vulnerabilities = append(vulnerabilities, configVulns...)
	return vulnerabilities
}

// scanAuthenticationSecurity scans for authentication-related security vulnerabilities
func (vs *VulnerabilityScanner) scanAuthenticationSecurity() []*Vulnerability {
	var vulnerabilities []*Vulnerability

	authVulns := []*Vulnerability{
		{
			ID:          "AUTH-001",
			Name:        "Weak Password Policy",
			Description: "Password policy may not meet security requirements",
			Severity:    SeverityHigh,
			Category:    CategoryAuthentication,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Implement strong password policies with complexity requirements",
			Context:     map[string]interface{}{"scan_type": "auth"},
		},
		{
			ID:          "AUTH-002",
			Name:        "Missing Multi-Factor Authentication",
			Description: "Multi-factor authentication is not enforced",
			Severity:    SeverityHigh,
			Category:    CategoryAuthentication,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Implement and enforce multi-factor authentication",
			Context:     map[string]interface{}{"scan_type": "auth"},
		},
		{
			ID:          "AUTH-003",
			Name:        "Session Security Issues",
			Description: "Session management may have security weaknesses",
			Severity:    SeverityMedium,
			Category:    CategoryAuthentication,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Review and strengthen session management security",
			Context:     map[string]interface{}{"scan_type": "auth"},
		},
	}

	vulnerabilities = append(vulnerabilities, authVulns...)
	return vulnerabilities
}

// scanEncryptionSecurity scans for encryption-related security vulnerabilities
func (vs *VulnerabilityScanner) scanEncryptionSecurity() []*Vulnerability {
	var vulnerabilities []*Vulnerability

	encryptionVulns := []*Vulnerability{
		{
			ID:          "ENC-001",
			Name:        "Weak Encryption Algorithm",
			Description: "Weak encryption algorithms may be in use",
			Severity:    SeverityHigh,
			Category:    CategoryEncryption,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Use strong encryption algorithms (AES-256, RSA-2048+)",
			Context:     map[string]interface{}{"scan_type": "encryption"},
		},
		{
			ID:          "ENC-002",
			Name:        "Insufficient Key Management",
			Description: "Encryption key management practices may be insufficient",
			Severity:    SeverityHigh,
			Category:    CategoryEncryption,
			DetectedAt:  time.Now(),
			Status:      StatusNew,
			Remediation: "Implement proper key rotation and management procedures",
			Context:     map[string]interface{}{"scan_type": "encryption"},
		},
	}

	vulnerabilities = append(vulnerabilities, encryptionVulns...)
	return vulnerabilities
}

// initializeVulnerabilityPatterns initializes common vulnerability detection patterns
func (vs *VulnerabilityScanner) initializeVulnerabilityPatterns() {
	patterns := []*VulnerabilityPattern{
		{
			ID:          "PATTERN-001",
			Name:        "SQL Injection Pattern",
			PatternStr:  `(?i)(union|select|insert|update|delete|drop|create|alter)\s+.*\s+(from|into|table|database)`,
			Severity:    SeverityCritical,
			Category:    CategoryInjection,
			Description: "Potential SQL injection vulnerability detected",
			Remediation: "Use parameterized queries and input validation",
			Enabled:     true,
		},
		{
			ID:          "PATTERN-002",
			Name:        "Command Injection Pattern",
			PatternStr:  `(?i)(exec|system|eval|passthru|shell_exec)\s*\(`,
			Severity:    SeverityHigh,
			Category:    CategoryInjection,
			Description: "Potential command injection vulnerability detected",
			Remediation: "Avoid dynamic command execution, use safe alternatives",
			Enabled:     true,
		},
		{
			ID:          "PATTERN-003",
			Name:        "Path Traversal Pattern",
			PatternStr:  `\.\.\/|\.\.\\`,
			Severity:    SeverityMedium,
			Category:    CategoryDataExposure,
			Description: "Potential path traversal vulnerability detected",
			Remediation: "Validate and sanitize file paths",
			Enabled:     true,
		},
	}

	for _, pattern := range patterns {
		if compiled, err := regexp.Compile(pattern.PatternStr); err == nil {
			pattern.Pattern = compiled
			vs.patternMatchers = append(vs.patternMatchers, pattern)
		}
	}
}

// GetVulnerability retrieves a vulnerability by ID
func (vs *VulnerabilityScanner) GetVulnerability(id string) (*Vulnerability, bool) {
	vs.mutex.RLock()
	defer vs.mutex.RUnlock()

	vuln, exists := vs.knownVulns[id]
	return vuln, exists
}

// GetVulnerabilitiesBySeverity retrieves vulnerabilities by severity level
func (vs *VulnerabilityScanner) GetVulnerabilitiesBySeverity(severity VulnerabilitySeverity) []*Vulnerability {
	vs.mutex.RLock()
	defer vs.mutex.RUnlock()

	var vulnerabilities []*Vulnerability
	for _, vuln := range vs.knownVulns {
		if vuln.Severity == severity {
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}

	return vulnerabilities
}

// UpdateVulnerabilityStatus updates the status of a vulnerability
func (vs *VulnerabilityScanner) UpdateVulnerabilityStatus(id string, status VulnerabilityStatus) error {
	vs.mutex.Lock()
	defer vs.mutex.Unlock()

	vuln, exists := vs.knownVulns[id]
	if !exists {
		return fmt.Errorf("vulnerability %s not found", id)
	}

	vuln.Status = status
	return nil
}

// GetScanHistory returns the scan history
func (vs *VulnerabilityScanner) GetScanHistory() []*ScanResult {
	vs.mutex.RLock()
	defer vs.mutex.RUnlock()

	return vs.scanHistory
}

// GetLatestScanResult returns the most recent scan result
func (vs *VulnerabilityScanner) GetLatestScanResult() *ScanResult {
	vs.mutex.RLock()
	defer vs.mutex.RUnlock()

	if len(vs.scanHistory) == 0 {
		return nil
	}

	return vs.scanHistory[len(vs.scanHistory)-1]
}

// GetSecurityDashboard returns a comprehensive security dashboard
func (vs *VulnerabilityScanner) GetSecurityDashboard() *SecurityDashboard {
	vs.mutex.RLock()
	defer vs.mutex.RUnlock()

	dashboard := &SecurityDashboard{
		LastScanTime:         time.Time{},
		TotalVulnerabilities: len(vs.knownVulns),
		VulnerabilityBreakdown: VulnerabilityBreakdown{
			Critical: 0,
			High:     0,
			Medium:   0,
			Low:      0,
			Info:     0,
		},
		CategoryBreakdown: make(map[VulnerabilityCategory]int),
		StatusBreakdown:   make(map[VulnerabilityStatus]int),
		RecentScans:       []*ScanResult{},
	}

	// Calculate vulnerability statistics
	for _, vuln := range vs.knownVulns {
		switch vuln.Severity {
		case SeverityCritical:
			dashboard.VulnerabilityBreakdown.Critical++
		case SeverityHigh:
			dashboard.VulnerabilityBreakdown.High++
		case SeverityMedium:
			dashboard.VulnerabilityBreakdown.Medium++
		case SeverityLow:
			dashboard.VulnerabilityBreakdown.Low++
		case SeverityInfo:
			dashboard.VulnerabilityBreakdown.Info++
		}

		dashboard.CategoryBreakdown[vuln.Category]++
		dashboard.StatusBreakdown[vuln.Status]++
	}

	// Add recent scans (last 5)
	scanCount := len(vs.scanHistory)
	if scanCount > 0 {
		dashboard.LastScanTime = vs.scanHistory[scanCount-1].EndTime

		start := scanCount - 5
		if start < 0 {
			start = 0
		}
		dashboard.RecentScans = vs.scanHistory[start:]
	}

	return dashboard
}

// SecurityDashboard represents a security overview dashboard
type SecurityDashboard struct {
	LastScanTime           time.Time                     `json:"last_scan_time"`
	TotalVulnerabilities   int                           `json:"total_vulnerabilities"`
	VulnerabilityBreakdown VulnerabilityBreakdown        `json:"vulnerability_breakdown"`
	CategoryBreakdown      map[VulnerabilityCategory]int `json:"category_breakdown"`
	StatusBreakdown        map[VulnerabilityStatus]int   `json:"status_breakdown"`
	RecentScans            []*ScanResult                 `json:"recent_scans"`
}

// VulnerabilityBreakdown represents vulnerability counts by severity
type VulnerabilityBreakdown struct {
	Critical int `json:"critical"`
	High     int `json:"high"`
	Medium   int `json:"medium"`
	Low      int `json:"low"`
	Info     int `json:"info"`
}

// IsSecurityPostureAcceptable checks if the current security posture is acceptable
func (vs *VulnerabilityScanner) IsSecurityPostureAcceptable() bool {
	vs.mutex.RLock()
	defer vs.mutex.RUnlock()

	criticalCount := 0
	highCount := 0

	for _, vuln := range vs.knownVulns {
		if vuln.Status == StatusNew || vuln.Status == StatusConfirmed {
			switch vuln.Severity {
			case SeverityCritical:
				criticalCount++
			case SeverityHigh:
				highCount++
			}
		}
	}

	// Check against thresholds
	if criticalCount > vs.config.CriticalVulnThreshold {
		return false
	}

	if highCount > vs.config.HighVulnThreshold {
		return false
	}

	return true
}
